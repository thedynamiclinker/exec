# exec/etc/bashrc
# LD's custom ~/.bashrc. Woot!

export EXEC="$(readlink -f "${BASH_SOURCE[0]}" | xargs dirname | xargs dirname)"
export PATH="${EXEC}/bin:${EXEC}/lib/bash:${PATH}"

source os.sh
source log.sh
source paths.sh
source which.sh

if is_bash && is_linux; then
    shopt -s globstar # allow ** to glob recursively
    shopt -s extglob  # allows @(patterns), *(patterns), +(patterns), !(patterns)
fi

#############################
### environment variables ###
#############################

# directories
export DESKTOP="$HOME/Desktop"

# programs
export VISUAL='vim'
export EDITOR='vim'
export GEDITOR='gedit'
export TERMINAL='gnome-terminal'

######################
### the dirs array ###
### ============== ###
### cd to anywhere ###
### from anywhere! ###
######################

# used by:
# p: prints directories
# o: opens directories
# c: cd into directories

source dirs.sh

#unset dirs
declare -A dirs
dirs+=(
    [exec]="${EXEC}"
    [exec/bin]="${EXEC}/bin"
    [exec/lib]="${EXEC}/lib"
    [exec/etc]="${EXEC}/etc"
)

# EXPERIMENTAL: Can we define slashed tab-completable array keys
# with c, o, and p, in which the slashes don't correspond to specific file paths?
unset files
declare -A files
files+=(
    [bashrc]="${HOME}/.bashrc"
    [bashrc/exec]="${EXEC}/etc/bashrc"
)

###########################
### python environments ###
###########################

source python.sh

########################
### get search paths ###
########################

paths=(
    "${EXEC}/bin"
    "${EXEC}/lib/bash"
)

python_paths=(
    "${EXEC}/lib/python"
)

ld_library_paths=(
    # cuda library paths
)

###################
### PS1 and PS2 ###
###################

source colors.sh

is_bash && {

    if [[ ${EUID} == 0 ]]; then
        export PS1="${_red}\u${_gre}@${_blu}\h${_pur} \W ${_blu}\$${_end} "
    else
        export PS1="${_gre}\u${_red}@${_blu}\h${_pur} \w ${_blu}\$${_end} "
    fi

    if which emerge &>/dev/null; then
        if [[ ${EUID} == 0 ]]; then
            PS1=(
                "${_red}${USER:0:1}"
                "${_whi}${USER:1:1}"
                "${_red}${USER:2:1}"
                "${_whi}${USER:3:1}"
                "${_red}${USER:4:1}"
                "${_whi}@"
                "${_red}g"
                "${_whi}e"
                "${_red}n"
                "${_whi}t"
                "${_red}o"
                "${_whi}o"
            )
        else
            PS1=(
                "${_red}${USER:0:1}"
                "${_yel}${USER:1:1}"
                "${_cya}${USER:2:1}"
                "${_blu}${USER:3:1}"
                "${_pur}${USER:4:1}"
                "${_end}@"
                "${_red}g"
                "${_yel}e"
                "${_cya}n"
                "${_blu}t"
                "${_pur}o"
                "${_whi}o"
            )
        fi
        export PS1="$(echo ${PS1[@]} | tr -d ' ') ${_pur}\w ${_blu}\$ ${_end}"
    fi

    export PS2="${_blu}>>${_end} "
}


########################
### set search paths ###
########################

# PATH
for d in ${paths[@]}; do
    [[ -d "$d" ]] && add_to_path "$d"
done

# PYTHONPATH
for d in ${python_paths[@]}; do
    [[ -d "$d" ]] && add_to_python_path "$d"
done

# LD_LIBRARY_PATH
for d in ${ld_library_paths[@]}; do
    add_to_ld_library_path "$d"
done

unset d

if [[ -n ${BASH_VERSION:-} && $- == *i* ]]; then
    source completion.sh
    for completion in "${EXEC}/lib/bash/completions"/*.sh; do
        source "$completion"
    done
fi

# export the variables for subprocesses
export PATH="$PATH"
export PYTHONPATH="$PYTHONPATH"
export LD_LIBRARY_PATH="$LD_LIBRARY_PATH"

is_linux && {

    # hidpi thing changed
    export QT_SCALE_FACTOR=1

    if which ibus &>/dev/null; then
        export GTK_IM_MODULE=ibus
        export XMODIFIERS=@im=ibus
        export QT_IM_MODULE=ibus
    fi

    # wireless and ethernet devices
    #[[ -d /sys/class/net ]] && {
        #export WDEV="$(ls /sys/class/net/ | grep -m1 '^w')"
        #export EDEV="$(ls /sys/class/net/ | grep -m1 '^e')"
    #    true
    #}

    # terminal colors
    [[ "$TERM" = "xterm" ]] && export TERM=xterm-256color
    [[ "$TERM" = "linux" ]] && export DISPLAY=:0.0 # to fix ipython's crash on ttys

    export XAUTHORITY="$HOME/.Xauthority"

    # set the terminal's title bar
    export PROMPT_COMMAND='echo -ne "\e]0;Your command is my wish: ${PWD##*/}\007"'

    # GREP_COLORS
    # the only one we changed is fn=35 (purple, non-bold) to fn=01;34 (blue, bold).
    export GREP_COLORS='ms=01;31:mc=01;31:sl=:cx=:fn=01;34:ln=32:bn=32:se=36'

    # determine SWAP partition
    #export SWAP="$(cat /proc/swaps | tail -n +2 | cut -f1 -d' ')"
}

############################################################
### everything after this is only for interactive shells ###
############################################################

# if not interactive, gtfo
if [[ $- != *i* ]] ; then
    return
fi

# if we're starting-up in a directory with a really-long
# pathname, then switch to a shorter prompt automatically
source ps1.sh
clip_prompt_if_its_super_long

###############
### ALIASES ###
###############

# hooks
alias ls="ls -h --color=auto --group-directories-first"
alias l="ls -1"
alias ll="ls -al"
alias duh="du -hd0"
alias grep="grep -P --color=auto --exclude-dir=.git --exclude='*.html' --exclude='*.ps' --exclude='*.pdf' --exclude-dir='__pycache__' --exclude='*.pyc'"
alias less="less -R"
alias lsof='lsof +c 15'  # show as many characters of process name as we can
alias diff='diff -u'

# sudos
alias reboot='sudo reboot'
alias updatedb='sudo updatedb'
alias tcpdump='sudo tcpdump'
alias iftop='sudo iftop'
alias iotop='sudo iotop'
alias powertop='sudo powertop'
alias insmod='sudo insmod'
alias rmmod='sudo rmmod'
alias modprobe='sudo modprobe'
alias str='suspend-to-ram'

# fundamentals
alias v='vim -p'
alias vim='vim -p'
alias x='exit'
alias d='sudo dmesg --color=always'
alias dn='dirname'
alias bn='basename'
alias e0='echo $?'
alias pn='ping -c 4 -i 0.2 google.com'
alias sv="sudo vim"
alias ta='tree -a'
alias y='ytdl'
alias yy='ytdl --extract-audio --audio-format=mp3 -o "%(title)s.%(ext)s"'
alias mvv='mv -v'
alias cpv='cp -v'
alias rmv='rm -v'
alias sm='synergy-share'
alias ud='updatedb'
alias rn='ranger'
alias e="$EDITOR"
alias b='popd'

# download highest quality
## bv* = best video (any codec, any container)
## ba  = best audio
## /b  = fallback to best single-file format if merging isn't possible
alias Y='ytdl -f "bv*+ba/b"'

# python
_IPYTHON_ARGS=(
    --colors=Linux
    --nosep
    --TerminalInteractiveShell.prompts_class=IPython.terminal.prompts.ClassicPrompts
    --TerminalInteractiveShell.highlight_matching_brackets=False
    --TerminalInteractiveShell.autoformatter=None
)

pip()       { python -m pip $@; }
pdb()       { python -m pdb $@; }
pytest()    { python -m pytest $@; }
py()        { python -m IPython ${_IPYTHON_ARGS[*]} $@; }

pip11()     { python3.11 -m pip $@; }
pdb11()     { python3.11 -m pdb $@; }
pytest11()  { python3.11 -m pytest $@; }
py11()      { python3.11 -m IPython ${_IPYTHON_ARGS[*]} $@; }

pip12()     { python3.12 -m pip $@; }
pdb12()     { python3.12 -m pdb $@; }
pytest12()  { python3.12 -m pytest $@; }
py12()      { python3.12 -m IPython ${_IPYTHON_ARGS[*]} $@; }

py13()      { python3.13 $@; }
pip13()     { python3.13 -m pip $@; }
pdb13()     { python3.13 -m pdb $@; }
pytest13()  { python3.13 -m pytest $@; }
py13()      { python3.13 -m IPython ${_IPYTHON_ARGS[*]} $@; }

py14()      { python3.14 $@; }
pip14()     { python3.14 -m pip $@; }
pdb14()     { python3.14 -m pdb $@; }
pytest14()  { python3.14 -m pytest $@; }
py14()      { python3.14 -m IPython ${_IPYTHON_ARGS[*]} $@; }

py15()      { python3.15 $@; }
pip15()     { python3.15 -m pip $@; }
pdb15()     { python3.15 -m pdb $@; }
pytest15()  { python3.15 -m pytest $@; }
py15()      { python3.15 -m IPython ${_IPYTHON_ARGS[*]} $@; }

py13t()     { python3.13t $@; }
pip13t()    { python3.13t -m pip $@; }
pdb13t()    { python3.13t -m pdb $@; }
pytest13t() { python3.13t -m pytest $@; }
py13t()     { python3.13t -m IPython ${_IPYTHON_ARGS[*]} $@; }

py14t()     { python3.14t $@; }
pip14t()    { python3.14t -m pip $@; }
pdb14t()    { python3.14t -m pdb $@; }
pytest14t() { python3.14t -m pytest $@; }
py14t()     { python3.14t -m IPython ${_IPYTHON_ARGS[*]} $@; }

py15t()     { python3.15t $@; }
pip15t()    { python3.15t -m pip $@; }
pdb15t()    { python3.15t -m pdb $@; }
pytest15t() { python3.15t -m pytest $@; }
py15t()     { python3.15t -m IPython ${_IPYTHON_ARGS[*]} $@; }

3()         { python3.13 -m IPython ${_IPYTHON_ARGS[*]} $@; }
4()         { python3.14 -m IPython ${_IPYTHON_ARGS[*]} $@; }
5()         { python3.15 -m IPython ${_IPYTHON_ARGS[*]} $@; }
3t()        { python3.13t -m IPython ${_IPYTHON_ARGS[*]} $@; }
4t()        { python3.14t -m IPython ${_IPYTHON_ARGS[*]} $@; }
5t()        { python3.15t -m IPython ${_IPYTHON_ARGS[*]} $@; }

#hack="PYTHONPATH=$HOME/.local/lib/python${PV}/site-packages"
#alias Python="$hack python${PV}" # horrible, just horrible
#alias Pip="$hack python${PV} -m pip"
#alias Pdb="$hack python${PV} -m pdb"
#alias Py="$hack python${PV} -m IPython ${_IPYTHON_ARGS[*]}"

# fundamentals: lower priority
alias po='acpi'
alias ds='date +%Y%m%d'
alias dl='date +%Y%m%d-%H%M%S'
alias dx="sudo dmesg -C"
alias update-grub='sudo grub-mkconfig -o /boot/grub/grub.cfg && sudo grub-install --efi-directory=/boot/efi --bootloader-id="grub"'
alias srm='srm -fllvz'
alias un7zip='7z x'

# our commands
alias fn='fixnames'
alias fns='fixnames -s'
alias fni='fixnames -i'
alias pd='prefix-date -i'
alias pds='prefix-date -i -s'
alias ffc='ffmpeg-crop'
alias cl='clean'
alias ca='clean' # legacy alias, now that `clean` is the default
alias caa='clean -a'

# config files
alias src="source ${HOME}/.bashrc"
alias brc="$EDITOR ${HOME}/.bashrc && source ${HOME}/.bashrc"
alias brce="c exec && $EDITOR ${EXEC}/etc/bashrc && source ${HOME}/.bashrc"
alias vrc="$EDITOR ~/.vimrc"

# general
alias xa='xargs'
alias xargsnewlines="xargs -d '\n'"
alias upper='tr a-z A-Z'
alias lower='tr A-Z a-z'
alias feh="feh -. -B black"
alias entropy='binwalk -EJ'
alias H='heisig'
alias P='pinyin'
alias ct='column -t'

# tmux
alias tm='tmux'
alias tma='tmux attach'
alias tmd='tmux detach'
alias tmlk='tmux list-keys'

# debian
alias apt='sudo apt'
alias saa='sudo apt autoremove'
alias sau='sudo apt update && sudo apt upgrade'

# arch
alias pacman="sudo pacman --color auto"
alias pacaur="pacaur --color auto"
alias pacclean='pacman -Rs $(pacman -Qdtq)'

# gentoo
alias emerge='sudo emerge'
alias epmc='sudo vim /etc/portage/make.conf'
alias eppu='sudo vim /etc/portage/package.use'
alias eppm='sudo vim /etc/portage/package.mask'
alias eppum='sudo vim /etc/portage/package.unmask'
alias eppl='sudo vim /etc/portage/package.license'
alias eppak='sudo vim /etc/portage/package.accept_keywords'

# systemd
alias ss="sudo systemctl"
alias sss="sudo systemctl start"
alias ssS="sudo systemctl stop"
alias sst="sudo systemctl status"
alias ssr="sudo systemctl restart"
alias sse="sudo systemctl enable"
alias ssd="sudo systemctl disable"
alias ssia="sudo systemctl is-active"
alias ssie="sudo systemctl is-enabled"
alias ssdrl='sudo systemctl daemon-reload'
alias ssrnm='sudo systemctl restart NetworkManager'
alias ssrldm='sudo systemctl restart lightdm'

# cds
alias de="c desktop && clear"
alias cdb="c bin"
alias cdk="cd /usr/src/linux"

# git
alias gs='git status'
alias gb='git branch'
alias gba='git branch --all'
alias gp='git pull'
alias gpp='git push'
alias gd='git diff'
alias gds='git diff --staged'
alias gl='git log'
alias gla='git log --all --graph --decorate'
alias ga='git add .'
alias gap='git add --patch .'
alias gac='git add . && git commit'
alias gacm='git add . && git commit -m'
alias gaca='git add . && git commit --amend'
alias gacan='git add . && git commit --amend --no-edit'
alias gc='git commit'
alias gcm='git commit -m'
alias gca='git commit --amend'
alias gcan='git commit --amend --no-edit'
alias grs='git remote show'
alias grso='git remote show origin'
alias grsu='git remote show upstream'
alias gaita='git add --intent-to-add .'
alias grhh='git reset --hard HEAD'
alias gsm='git switch master 2> /dev/null || git switch main'

alias g+='git add . && git commit --amend --no-edit && git pull'
alias gg='git add . && git commit && git pull && git push'

# gits
alias ggs='gits status'
alias ggb='gits branch'
alias ggp='gits pull'
alias ggd='gits diff'
alias ggl='gits log'
alias gga='gits add .'
alias ggc='gits commit'
alias ggg='gits add . && gits commit && gits pull && gits push'

# ctags
alias tags="universal-ctags -f .git/tags --recurse --tag-relative=yes --fields=+l --extras=+q --kinds-all=* --exclude=.git --exclude=.direnv --exclude='result*'"

# readline
type bind &>/dev/null && {
    # this makes C-o kill everything to the following whitespace, 
    # like how C-w kills everything to the previous whitespace.
    bind '"\C-o": "\C-]\ \C-f\C-w"'

    # this makes alt+j and alt+k move backward and forward on space-delimited words.
    bind '"\ej":shell-backward-word'
    bind '"\ek":shell-forward-word'

    # this makes C-b run cowsay
    bind -x '"\C-b":cowsay boop'
}


#######################
### shell functions ###
#######################

reset_IFS() {
    # This is one of the few things in bash that can be done
    # in seemingly only ONE way, and that way is obscure as fuck
    IFS=$' \t\n'
}

reterm() {
    exec $TERMINAL --working-directory="$PWD" --maximize
}

cddn() {
    # cddn: cd dirname
    pushd "$(dirname "$1")" >/dev/null;
}

chx() {
    # chmod as user || as root if needed
    chmod +x "$@" 2>/dev/null || sudo chmod +x "$@";
}

enter() {
    # enter a directory, creating it if necessary
    [[ -z "$1" ]] && echo "usage: ${FUNCNAME} <new-dir>" && return
    mkdir -pv "$1" && pushd "$1" 2>/dev/null
}

vx() {
    for f in "$@"; do
        touch "$f" && chmod +x "$f"
    done
    vim -p "$@"
}

unixjoke() {
    # classic
    cat << "EOF"
    unzip; strip; touch; grep;
    finger; mount; fsck;
    more; yes; umount; sleep;
EOF
}

field() {
    awk "{print \$$1}"
}

# convert
jpg() { for f in $(ls | grep -P '\.(webp|avif|gif)$'); do magick "$f" "${f%.*}.jpg" && rm "$f"; done; }
png() { for f in $(ls | grep -P '\.(webp|avif|gif)$'); do magick "$f" "${f%.*}.png" && rm "$f"; done; }

# copy to desktop
cpdt() {
    cp -v "$@" ~/Desktop
}

ff() {
    find ! -path "*/.git*" | grep -P $@
}

eff() {
    $EDITOR $(ff $@)
}

hashes() {
    nix-prefetch-github --nix $(git remote get-url origin | sed -e 's@https://github.com/@@' -e 's@[.]git$@@' -e 's@/@ @')
}

###########
### nix ###
###########

if [[ $(getdistro) == nixos ]]; then
    alias locate='sudo plocate'
fi

if [[ -e "$HOME/.nix-profile/bin" ]]; then
    add_to_path "$HOME/.nix-profile/bin"
fi

nrb() {
    if [[ $(getdistro) == nixos ]]; then
	    sudo nixos-rebuild --print-build-logs switch --flake .#$(hostname)
    else
        sudo nixos-rebuild switch
    fi
}

nixos_rebuild_switch() { sudo nixos-rebuild switch; }
nixos_rebuild_repl() { sudo nixos-rebuild repl; }
nixos_edit_config() { sudo $EDITOR /etc/nixos/configuration.nix; }
nix_edit_config() { $EDITOR "$HOME/.config/nix/nix.conf"; }
nix_search() { nix search nixpkgs $@; }
nix_derivation_show() { nix derivation show "$1" | jq; }
nix_find() { find "/nix/store" -type f | grep -P "$1"; }
nix_flake_show() { nix flake show; }
nix_profile_list() { nix profile list; }
nix_profile_remove() { nix profile remove "$1"; }
nix_search() { nix search nixpkgs "$1"; }
nix_which() { nix path-info "${2:-nixpkgs}#${1}"; }
nix_get_nixos_install_tools() { nix profile add "nixpkgs#nixos-install-tools"; }
nixos_rebuild_boot() { nixos-rebuild boot --flake ".#$(hostname)"; }
nixos_list_generations() { nix-env --list-generations --profile /nix/var/nix/profiles/system; }
nixos_delete_generations() { sudo nix-env -p /nix/var/nix/profiles/system --delete-generations +${1:-2}; }

alias n="echo /etc/nixos/configuration.nix"
alias nn="cat /etc/nixos/configuration.nix"
alias nw="nix_which"
alias ns="nix search nixpkgs"
alias npl="nix profile list"
alias npr="nix profile remove"
alias nrcp="sudo $EDITOR /etc/nixos/python.nix"
alias nrr="sudo nixos-rebuild repl"
alias nfu="nix flake update && git add . && git commit"
alias nr="nix repl --expr 'let pkgs = import <nixpkgs> {}; in pkgs'" # tab complete on nixpkgs
alias nrc="c nix && $EDITOR -p configuration.nix"
alias nrcf="c nix && $EDITOR -p flake.nix"
alias cdh="c home-manager"
alias hms="ensure_in home-manager && home-manager switch"
alias ms="ensure_in nix; make system"
alias mh="ensure_in nix && make home"
alias m="ensure_in nix && make"

# Dear Rara,
# If and when stuff breaks for ya (because the hell lines are now commented out)
# just add this to configuration.nix:
# ============================================
#  programs.nix-ld.enable = true;
#  programs.nix-ld.libraries = with pkgs; [
#    zlib
#    stdenv.cc.cc.lib
#  ];
# ============================================
#
# Update: Fucking jesus numpy, ok, reverting for now
#
# ============================================
#
# Update to the Update: Fuck it.
# Doing the smart thing that I
# should have done forever ago.
#
# ============================================

if command -v nix > /dev/null; then
    if [[ ! -e "$HOME/.goddammitnix" ]]; then
        for pkg in zlib gcc.cc.lib; do
            nix path-info "nixpkgs#$pkg" 2>/dev/null >> "$HOME/.goddammitnix"
        done
    fi
    mapfile -t < ~/.goddammitnix
    for path in ${MAPFILE[@]}; do
        add_to_ld_library_path "${path}/lib"
    done
fi

export LIBGL_ALWAYS_INDIRECT=1

export PYTHONDONTWRITEBYTECODE=1

# git tab completion for the juicy sexy plumbing commands!
export GIT_COMPLETION_SHOW_ALL_COMMANDS=1

# but don't interfere with tab completion on git commit,
# so exclude completion for the plumbing commands
# git commit-graph and git commit-tree
git_completions_file="$(dirname "$(dirname "$(realpath "$(which git)")")")"/share/git/contrib/completion/git-completion.bash
source <(cat "$git_completions_file" | sed -E 's@(.*__gitcomp.*--list-cmds[^)]*)[)]@\1 | grep -v commit-)@g')

# complete our `gits` command the same as `git` itself,
# since it supports all the same commands as plurals.
___git_complete gits __git_main
